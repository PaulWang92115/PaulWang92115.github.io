---
layout:     post
title:      "Redis单机数据库的实现"
subtitle:   "Redis，数据库，持久化"
date:       2019-04-14
author:     "Paul"
header-img: "img/post-bg-js-module.jpg"
tags:
    - Redis
    - 数据库
    - 持久化
---

> Redis设计与实现系列

每个Redis服务器默认会创建16个数据库。每个Redis客户端都有自己的目标数据库，默认情况下，Redis客户端的目标数据库为0号。可以通过SELECT命令自由切换数据库。

通过EXPIRE命令或者PRXPIRED命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间。过期自动删除。PERSIST命令可以移除一个键的过期时间。



* 过期键的删除策略

  如果一个键过期了，那么它什么时候会被删除那？

  * 定时删除：设置键的过期时间的同时，创建一个定时器，在键过期时，立即执行对键的删除操作。
  * 惰性删除：放任键过期不管，在获取这个键时如果这个键已经过期，则删除。
  * 定时删除：每隔一段时间，程序对数据库进行检查，删除里面的过期键。

  Redis服务器实际使用的是惰性删除和定期删除两种策略。

  在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，已经过期的键不会保存到新的RDB文件中。

  当服务器以AOF持久化模式运行时，如果数据库中的某个键一斤过期但是还没有被惰性或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响，当被删除后，程序会想AOF文件追加一条DEL命令。

  在执行AOF重写过程中，过期的键不会被保存到重写后的AOF文件中。



# RDB持久化

RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行。RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时数据库的状态。

REDIS中有两个命令用于生成RDB文件，一个是SAVE（会阻塞服务器进程，在此期间服务器不能处理任何命令请求），另一个是BGSAVE（会派生出一个子进程，然后由子进程负责创建RDB文件，父进程继续处理命令请求）。

只要服务器检测到有RDB文件存在，就会自动载入RDB文件，载入时也会阻塞。

如果AOF持久化也开启了，服务器会优先使用AOF文件来还愿数据库。

因为BGSAVE命令可以在不阻塞服务器的情况下执行，所以可以通过设置让服务器每隔一段时间就自动执行一次BGSAVE命令。

```c
save 900 1
save 300 10
save 60  10000
  
//第二个参数是服务器对数据库的修改次数。
```



# AOF持久化

与RDB持久化通过数据库中的键值来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。

AOF持久化功能的实现可以分为命令追加，文件写入，文件同步三个步骤。

* 命令追加

  写命令会以协议的格式追加到aof_buf缓冲区的末尾。

* 文件写入

  服务器每结束一次事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否要将aof_buf缓冲区的内容写入和保存到AOF文件里面。这个函数的同步策略由appendfsync选项的值来决定。

  ```c
  always      //将aof_buf缓冲区中的所有内容写入并同步到AOF文件。
  everysec    //将aof_buf缓冲功区中所有内容写入到AOF文件，每隔一秒进行一次文件同步。
  no          //将aof_buf缓冲区中的所有内容写入到AOF文件，但并不对AOF文件进行同步，何时同步由操作系统决定。
  ```

  

* 文件同步

  将缓冲区中的数据写入到AOF文件中。

**AOF重写**

为了控制AOF文件的体积，使用AOF重写来去掉一些重复的命令，将一些命令合并到一起。AOF文件重写并不需要对现有的AOF文件进行任何的读取，分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来完成的。





# 事件

Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：

* 文件事件

  Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器套接字操作的抽象。服务器通过监听并处理这些事件来完成一些列网络通信操作。

* 时间事件

  Redis服务中的一些操作需要在给定的事件点执行，而时间事件就是服务器对着咧定时操作的抽象。



# 复制

Redis中，可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制另一个服务器，主从复制。执行以下命令后：

```c
127.0.0.1:12345> SLAVEOF 127.0.0.1 6379
```

12345就成为了6379的从服务器。进行复制中的主从服务器双方的数据库将保存相同的数据。在主服务器上进行的操作会同步到从服务器。



最新版的复制功能使用PSYNC命令代理SYNC命令来执行复制时的同步操作。PSYNC命令具有完整同步和部分同步两种模式：

* 完成同步用于初次复制的情况：通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来同步。
* 部分同步用于处理短线后重复制的情况：主服务器可以将主从服务器断开连接期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态（通过检查复制偏移量来找到断开期间的数据差）。



# Sentinel

Sentinel（哨岗，哨兵）是Redis高可用的解决方案：由一个活多个Sentinel实例组成的Sentinel系统可以监视人意多个主服务器，以及这些主服务器属下的所有从服务器，当被监视的主服务器进入下线状态时，自动将下线的主服务器属下的某个从服务器升级为新的主服务器。



图片表示一个监视系统，双环为主，剩下三个为从，Sentinel系统则监视着所有四个服务器。

![sentinel](/imgblog/sentinel.png)





当一个Sentinel启动时，它需要执行以下步骤：

* 初始化服务器

  Sentinel本质上只是一个运行在特殊模式下的Redis服务器，所以启动Sentinel的第一步就是初始化一个普通的Redis服务器。Sentinel服务器不会载入RDB或者AOF文件来还原数据库。

* 将普通Redis服务器使用的代码替换为Sentinel专用代码

  Sentinel模式下，Redis服务器不能执行注入SET，DBSIZE，EVAL等等这些命令，因为服务器根本没有在命令表中载入这些命令。

* 初始化Sentinel

  在应用了Sentinel的专用代码后，接下来服务器会初始化一个Sentinel状态，这个状态保存了服务器中所有和Sentinel功能有关的状态。

* 根据给定的配置文件，初始化Sentinel的监视主服务器列表

  Sentinel状态中的masters字典记录了所有被Sentinel监视的主服务器的相关信息。

* 创建向主服务器的网络连接

  Sentinel成为了主服务器的客户端，它可以想主服务器发送命令，并从命令回复中获取相关的信息。Sentinel会创建两个连向主服务器的网络连接：一个时命令连接，这个连接专门用于向主服务器发送命令，并接收命令回复。另一个时订阅连接，这个连接专门用于订阅主服务器_sentinel_:hello频道。

**获取主服务器的信息**

Sentinel默认会以每十秒一次的频率向被监视的主服务器发送INFO命令，通过分析回复来获取主服务器的当前信息（包括下面的从服务器）。当Sentinel发现主服务器由新的从服务器时，Sentinel还会创建连接到从服务器的连接命令和订阅连接。

![info](/imgblog/info.png)



**客观下线**

当认为主服务器已经进入下线状态的Sentinel数量超过了配置中设置的quorum参数的值，那么该Sentinel就会认为主服务器已经进入客观下线状态。

```c
sentinel monitor master 127.0.0.1 6379 5
```

仅有两个Sentinel认为主服务器已下线，并不会令Sentinel将主服务器判断为客观下线。



**选举领头Sentinel**

当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，选举出一个领头Sentinel，并有领头Sentinel对下线的主服务器进行故障转移操作。

















