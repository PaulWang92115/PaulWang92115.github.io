---
layout:     post
title:      "Java内存区域与内存溢出异常"
subtitle:   "概述，运行时数据区域，对象访问，OutOfMemoryError异常"
date:       2019-03-26
author:     "Paul"
header-img: "img/post-bg-unix-linux.jpg"
tags:
    - JVM
    - 内存
    - 堆
    - 栈
    - 方法区
---

> 深入了解JVM系列



**概述**

不同于C和C++的内存管理机制（一个对象的生命开始到终结都需要程序员去维护），java在虚拟机的自动内存管理机制的帮助下，不需要为每一个new操作去写配对的delete/free代码，而且不容易出现内存泄漏和内存溢出问题。了解JVM内存的各个区域将有助于我们深入了解他的管理机制，避免出现问题和高效的解决问题。



**运行时数据区域**

Java虚拟机在执行Java程序过程中会把它所管理的内存分为若干个不同的数据区域，各自有各自的用途。

![timg](/imgblog/timg-3777485.jpeg)

线程私有的，可以看作是当前线程所执行字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支，循环，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。

这时唯一一个没有规定任何OOM异常的区域。

 * 虚拟机栈

   虚拟机栈也是线程私有的，生命周期与线程相同。栈里面存储的是方法的局部变量，对象的引用等等。在这片区域中，规定了两种异常情况，当线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。当虚拟机栈动态扩展无法申请到足够的内存时会抛出OOM异常。

 * 本地方法栈

   和虚拟机栈的作用相同，只不过它是为Native方法服务。HotSpot虚拟机直接将虚拟机栈和本地方法栈合二为一了。

 * 堆

   堆是Java虚拟机所管理内存中最大的一块。是所有线程共享的一块内存区域，在虚拟机启动时创建。这个区域唯一的作用就是存放对象实例，也就是new出来的对象。这个区域也是Java垃圾收集器的主要作用区域。Java堆还分为新生代和老年代（1:2），新生代又分为Eden，survivor，survivor（8:1:1），后面的文章会进行想写解释。

   当堆的大小再也无法扩展时，将会抛出OutOfMemoryError异常。

 * 方法区

   方法区也是线程共享的内存区域，用于存储已经被虚拟机加载的类信息，常量，静态变量等等。当方法区无法满足内存分配需求时，会抛出OOM异常。

 * 运行时常量池

   运行时常量池是方法区的一部分，Class文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。也会抛出OOM异常。

 * 直接内存

   直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。NIO操作时会直接使用的一块内存，虽然不受虚拟机参数限制，但是还是会收到本机总内存的限制，会抛出OOM异常。



**对象访问方式**

栈中存的都是对象的引用，实际的对象存在堆中，找到对象的主流访问方式有两种：句柄和直接指针。



* 句柄

  使用句柄方式，Java堆中将会划分出一块内存来作为句柄池。Reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。

  ![jubing1](/imgblog/jubing1.png)

* 直接指针

  如果使用直接指针方式访问类型数据的相关信息，reference中直接存储的就是对象地址。

  ![zhijiezhizhen](/imgblog/zhijiezhizhen.png)

  HotSpot虚拟机使用的是直接指针的方式访问。



**OutOfMemoryError**

栈溢出的典型例子：无法快速收敛的递归。

堆溢出的典型例子：集合持有对象并且长期不释放。

