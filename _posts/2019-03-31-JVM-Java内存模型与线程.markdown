---
layout:     post
title:      "Java内存模型与线程"
subtitle:   "内存模型，线程，锁"
date:       2019-03-31
author:     "Paul"
header-img: "img/post-bg-unix-linux.jpg"
tags:
    - JVM
    - 内存模型
    - 线程
    - 锁
---

> 深入了解JVM系列



**硬件效率与一致性**

计算机的存储设备（内存，磁盘）和处理器的运算速度有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存和处理器之间的缓冲。

将运算所需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后在从缓存同步回内存中，这样处理器就无需等待缓慢的内存读写了。

问题：缓存一致性，在多处理器系统中，每个处理器都有自己的高速缓存，他们又共享同一主内存，会有可能导致各自的缓存数据不一致的问题。为了解决这个问题，需要根据一些读写协议来操作（MSI，MESI，MOSI，Synapse）。

![hardmodel](/imgblog/hardmodel.png)

在硬件系统中，为了保证处理器内部的运算单元被充分利用，处理器可能会对输入代码进行乱序执行优化。Java虚拟机即时编译器也有类似的指令重排序优化。





**Java内存模型**

Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model）来屏蔽掉各种硬件和操作系统的内存访问差异，让Java在各种平台下都能达到一致的并发效果。

Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。这里的变量是指实例字段，静态字段和构成数组对象的元素，但是不包括局部变量和方法参数，因为后者是线程私有的，不会被共享。



**主内存和工作内存**

Java内存模型规定了所有变量都是存储在主内存（Main Memory）中。每条线程还有自己的工作内存，工作内存中保存了被改线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。线程直接通信要通过工作内存进行。工作内存中更改的变量会不定时刷新到主存中。

![javamemory](/imgblog/javamemory.png)

对于volatile型变量的特殊规则：

volatile可以说是Java虚拟机提供的最轻量级的同步机制，定义成volatile的字段能保证此变量对所有线程的可见性，修改后立刻刷新到主存，其他线程读取这个变量也要在主存中读取。volatile可以禁止指令重排序优化。

对于long和double型变量的特殊规则

对于64位的数据类型，在模型中规定，它允许将没有被volatile修饰的64为数据的读写划分为两次的32为来操作，即不保证他的原子性。不过目前各种平台的商用虚拟机机会都选择把64为的数据读写作为原子操作来对待，因为不需要专门为long和double声明volatile。





**Java与线程**

并发不一定要依赖多线程（PHP常见的多进程并发），但是在Java里面谈论并发，大多数都与线程脱不开关系。

线程是比进程更轻量级的调度单位，线程可以把一个进程的资源分配和调度执行分开，各个线程既可以共享进程资源，又可以独立调度。

Java中写一个线程有三种方式，继承Thread类，实现Runnable，实现Callable。对于Sun JDK来说，它的Windows与Linux版都是使用一对一的线程模型来实现的，一条Java线程就映射到一条轻量级进程之中。



**Java线程调度**

线程调度是指系统为线程分配处理器使用全的过程，只要调度方式有两种，分别是协同式线程调度和抢占式线程调度。

* 协同式调度，线程的执行时间由线程本身控制，线程执行完自己的工作后，主动通知系统切换到另一个线程上去。切换操作对线程自己是可知的，所以没有什么线程同步的问题。缺点是执行时间不可控制，一个线程阻塞后，程序可能一直阻塞在那里。

* 抢占式调度，每个线程都由操作系统来分配执行时间。在这种调度模式下，线程执行时间是可控的，也不会有一个线程导致整个进程阻塞的问题。Java就使用抢占式调度。

  虽然Java线程调度是系统自动完成的，但是我们还是可以通过优先级来选择为某个线程多分配一点时间。



**状态转换**

Java定义了5种线程状态，一个线程有且仅有其中一种状态。

* 新建（new）：创建后尚未启动的线程就处于这种状态。
* 运行（Runnable）：线程正在运行的状态。
* 就绪（Ready）：就绪状态，等待CPU分配时间片后就可以运行。
* 阻塞（Blocked）：可能是因为调用了wait方法进入阻塞（释放锁），也可能是sleep方法进入阻塞（不释放锁）。
* 结束（Terminated）：以终止线程的线程状态，线程已经结束执行。

![threadstatus](/imgblog/threadstatus.png)



**线程安全**

当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要额外的同步，或者在调用方法进行任何其他协同操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。 按照线程安全由强至弱来排序，我们可以将Java语言中各种操作共享的数据分为以下五类：

* 不可变

  在JDK 1.5 以后，不可变（Immutable）的对象一定是线程安全的，无论是对象的方法还是方法的调用者，都不需要再进行任何的线程安全保证措施。

  对于基本数据类型，使用final关键字修饰它就可以保证它是不可变的。

  如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行。比如java.lang.String类，它是典型的不可变对象，我们调用它的substring()，replace()，concat()方法不会影响它原来的值，只会返回一个新构造的字符串对象。

  除了String类之外，还有枚举没醒，java.lang.Number的部分子类，比如Long和Double的包装类，BigInteger和BigDecimal等大数据类型。

  

* 绝对线程安全

  绝对线程安全的定义是，一个类要达到"不管运行时环境如何，调用者都不需要任何额外的同步措施"。满足这个要求很难。

  比如java.util.Vector是一个线程安全的容器，它的add(),get(),size()等方法都被synchronized修饰。

  但是多线程对他同时操作时，他可能也不那么安全。

  

* 相对线程安全

  相对线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。

  Java中大部分的线程安全类都属于这个类型，比如Vector，HashTable，Collections的synchronizedCollection()方法包装的集合等。

  

* 线程兼容

  线程兼容指的是对象本身并不是线程安全的，但是通过在调用端正确的同步手段来保证对象在并发环境中安全的使用。平时说一个类不是线程安全的，绝大多数指的都是这种情况。比如Vector和HashTable对应的ArrayList和HashMap类。

  

* 线程对立

  线程对立是指不管调用端是否采用了同步措施，都无法在多线程环境中并发使用代码。这种代码多数是有害的，应当尽量避免。

  比如Thread类的suspend()和resume()方法，如果有两个线程同时持有一个对象，一个尝试去中断线程，一个尝试去恢复线程，如果并发进行，目标线程是存在死锁风险的，所以这两个方法已经废弃了。



**线程安全的实现方法**

互斥同步

java中最基本的同步手段就是synchronized关键字，synchronzied关键字在经过编译后，会在代码块前后分别形成monitorenter和monitorexit这两个字节码指令。这两个字节码需要一个对象来指明要锁定和解锁的对象。如果synchronized明确指定了对象参数，那么锁的就是这个对象，如果synchronized修饰的是方法和类，那么锁的就是对象实例或Class对象作为锁对象。

synchronized同步快对于已经获得锁的同一条线程来说是可重入的，不会出现锁死自己的问题。另外，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。

由于Java的线程是映射到操作系统的原生线程之上的，如果阻塞或唤醒一条线程，都需要操作系统来帮忙完成，这就需要从用户态转换到内核态，这个状态转换需要耗费很多的处理器时间。对于代码简单的同步快，状态转换消耗的时间可能比代码执行时间还长。所以synchronized是一个重量级锁。



除了synchronized之外，还可以是用JUC包中的重入锁（ReentrantLock）来实现同步。与synchronized相同的是，他们都具备线程重入的特性。ReentrantLock表现为API层面的互斥锁，synchronized是JVM底层实现的互斥锁。Lock接口的高级功能：

* 等待可中断指的是当前持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这对于处理时间非常长的同步块有很大的帮助。
* 公平锁指的是多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获取锁。synchronized时非公平的。
* 绑定多个条件指的是一个ReentrantLock对象可以同时绑定多个Condition对象。



非阻塞同步

互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也被称为阻塞同步，属于悲观的并发策略。另一种选择就是基于冲突检测的乐观并发策略，通俗的讲就是，先进行操作，如果没有其他线程争抢，那操作就成功了。

乐观的并发策略需要硬件指令集来完成的，用硬件来保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成。

* 测试并设置（Test-and-Set）
* 获取并增加（Fetch-and-Increment）
* 交换（Swap）
* 比较并交换（Compare and Swap，CAS）

CAS指令需要三个操作数，分别是内存位置V，旧的预期值A和新值B。当且仅当V符合预期值A时，处理器用新值B更新V的值，否则就不更新。AtomicInteger等类就是通过CAS实现的。



无同步方案

要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无需任何同步措施去保证正确性。

* 可重入代码：所有可重入代码都是线程安全的，在代码执行任何时刻中断它，转而去执行另外一段代码，返回后也不会出现任何错误。简单来说就是输入了相同的数据，就能返回相同的结果。

* 线程本地存储：把共享数据的可见范围限制在同一个线程之内，这样，无需同步也能保证线程之间不出现数据争用的问题。比如大部分的"生产者-消费者"模型，还有Web交互模型中的"一个请求对应一个服务器线程（Thread-per-Request）"的处理方式。

  Java中有ThreadLocl类来实现线程本地存储的功能。key是线程，value是线程的本地化值。



**锁优化**

* 自旋锁与自适应自旋

  为了避免线程的刮起和恢复带来的性能问题，可以让后面请求锁的那个线程等一会，不放弃处理器的执行时间，看看持有锁的线程是否很快就释放锁，让等待线程执行一个忙循环（自旋）。

  自适应自旋意味着自旋时间不固定了，而是由前一次在同一个锁上自旋时间以及锁拥有者的状态来决定，动态的确定自旋时间。

* 偏向锁

  大多数时候是不存在锁的竞争的，常常是一个线程多次获得同一个锁，为了减少每次竞争锁的代价，引入偏向锁。

  当线程1访问代码块并获取锁对象时，会在java对象头和栈帧中记录偏向的锁的threadID。因为偏向锁不会主动释放，所以当线程1在此想获取锁的时候，返现threadID一致，则无需使用CAS来加锁，解锁。如果不一致，线程2需要竞争锁，偏向锁不会主动释放里面还是存储线程1的threadID。如果线程1 没有存活，那么锁对象被重置为无锁状态，其他线程竞争并将其设置为偏向锁。如果线程1 还存活，那么查看线程1是否需要持有锁，如果需要，升级为轻量级锁。如果不需要设置为无锁状态，重新偏向。

* 轻量级锁

  轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景，为了避免阻塞线程让CPU从用户态转到内核态和代价，干脆不阻塞线程，直接让它自旋等待锁释放。

  线程1获取轻量级锁时会先把锁对象的对象头复制到自己的锁记录空间，然后使用CAS替换对象头的内容。

  如果线程1复制对象头的同时，线程2 也准备获取锁，但是线程2在CAS的时候失败，自旋，等待线程1释放锁。

  如果自旋到了次数线程1还没有释放锁，或者线程1在执行，线程2在自旋等待，这时3有来竞争，这个轻量级锁会膨胀为重量级锁，重量级锁把所有拥有锁的线程都阻塞，防止CPU空转。

  



